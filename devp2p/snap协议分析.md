

# 以太坊快照协议分析（SNAP）

该协议运行在RLPx之上，便于在peer之间交换以太坊状态快照。该协议是是可选的扩展。当前版本是 snap/1。

## 概述

该协议专为半实时数据获取而设计。它的目标是为peer提供最近状态的动态快照。该协议不参与链维护（块和交易传播），应该**与`eth`协议并行运行**。

协议本身在设计上很简单（但是实现起来非常复杂）。这个协议的关键是支持从以太坊状态 trie 中查询连续的帐户段数据，或从一个特定存储 trie 中检索连续的存储槽段。这两个查询都附带了merkle证明，以便可以立即验证。此外，还可以像`eth`协议一样批量查询bytecode。

该协议的同步机制是允许peer获取和校验所有的账户和存储数据，而不需要下载merkle树的中间节点，从而减小了网络负载。最终的状态 trie 将在本地重新组装。节点必须注意的另一个复杂性是，状态会随着链进行更改，因此同步器需要支持重新组装部分一致的状态片段，这是通过类似eth的获取trie node来解决的，这样可以修复trie的不一致性。

## 与`eth`协议的关系

该协议不是完全独立的，是*依赖eth的附属协议*，要允许snap，必须要同时允许eth。这是一个深思熟虑的设计决策：

- `snap`旨在为新加入的全节点提供bootstrap功能。通过强制所有snap节点也运行eth，可以避免非完整节点无限期地一直使用snap。
- `eth`已经包含完善的链和分叉协商机制，以及同步期间的远程peer过时检测。通过并行运行这两种协议，可以受益于所有这些机制。

该协议不是下一个版本的eth，因为它依赖于*快照*加速结构的可用性，该结构可以线性迭代帐户和存储槽位。它的用途也是一种特定的同步方法，可能不适合所有客户端。保持为单独的协议允许每个客户端决定是否采用它。

## 同步算法

快照同步的关键是可以获取连续范围的帐户和存储槽，因为他们是排序过的，因此构造的Merkle证明节点非常少。此简单算法的一些重要属性：

- 与fast sync相反，我们只需要从状态trie传输有用的叶子数据，并且可以在本地重建内部节点。
- 与warp sync相反 ，我们可以下载小块的帐户和存储插槽，并立即验证其Merkle证明，从而使垃圾攻击变得不可能。
- 与warp sync相反，可以检索随机帐户范围，因此同步的并发性完全依赖于客户端实现，并且不受协议的强制。

快照同步的注意事项是快照数据会不断变化，通过自我修复，我们可以从不同的trie导入snapshot chunks。自我修复的一些重要特性：

- 同步可以随时中止，后面可以恢复。尽管中止后，可能会导致自我修复运行更长时间；
- 网络比较慢也可以保证完成（只要节点下载的速度比生成数据的快就行），数据就不会从网络中消失（与warp sync相反）。

## 数据格式

协议中的帐户类似于以太坊RLP共识编码（相同的字段，相同的顺序），但采用**细长**的格式：

- codeHash使用empty list代替`Keccak256("")`
- Root使用empty list代替`Hash(<empty trie>)`

这样减少网络上传输大量普通账户的开销。

## 协议消息

### GetAccountRange （0x00）

```
[reqID: P, rootHash: B_32, startingHash: B_32, limitHash: B_32, responseBytes: P]
```

从给定root为rootHash的帐户 trie中一定数量的账户数据，请求未知数量的帐户，从指定的帐户哈希开始，并以允许的最大响应大小（以字节为单位）为上限：

* `reqID`：请求 ID 以便和相应关联；
* `rootHash`：帐户 trie 的根哈希

- `startingHash`：第一个要检索的帐户哈希
- `limitHash`：最后一个账户的hash
- `responseBytes`：返回数据的大小限制；

注意：

- 节点**必须**始终响应查询。
- 如果节点**没有**所请求状态根的状态，**则必须**返回空回复。调用方负责查询不超过 128 个块的状态。
- 允许响应节点返回的数据**少于**请求的数据（自己的 QoS 限制），但该节点**必须**至少返回一个帐户。如果在startingHash和limitHash之间不存在任何账户，则必须提供**之后**的第一个（如果有）帐户。
- 响应节点**必须**给出startingHash（即使这个账户不存在）和最后返回账户的默克尔证明。

理由：

- 起始帐户是故意通过哈希而不是地址来标识的。由于以太坊Merkle trie中的帐户按哈希排序，因此地址无关紧要。此外，没有共识要求全节点知道地址的pre-images。
- 响应以字节大小为上限，而不是以帐户数为上限，因为它使网络流量更具确定性。由于账户状态密度是不可知的，因此也无法仅用结束哈希来分隔查询。

警告：

- 从起始哈希请求帐户时，恶意节点可能会跳过并返回空隙回复。这样的回复会导致同步提前完成，并缺少大量数据。起始哈希值不存在的证明可防止此攻击，完全覆盖从头到尾的范围。
- 如果在最后一个返回的帐户之后没有更多的帐户，则不需要特殊信号，因为附加的最后一个帐户的Merkle证明的节点将都会是右边的节点。

### AccountRange（0x01）

```
[reqID: P, accounts: [[accHash: B_32, accBody: B], ...], proof: [node_1: B, node_2, ...]]
```

返回多个连续帐户和整个范围的 Merkle 边界证明。左侧证明必须用于请求的来源哈希（即使关联账户不存在），右侧证明必须是最后一个返回的账户。

- `reqID`：请求的 ID ；
- accounts：账户数据列表，每个包含acctHash(也是trie的路径)和accBody。
- `proof`：证明帐户范围的 trie 节点列表.

注意：

- 如果返回的响应包含了完整的状态，这可以不发送proof。对于账户来说可能不常见，但是对于存储来说很常见，因此这样子可以统一两者的行为。 



todo: 下面是直接机器翻译的，需要梳理。

### GetStorageRanges （0x02）

```
[reqID: P, rootHash: B_32, accountHashes: [B_32], startingHash: B, limitHash: B, responseBytes: P]
```

请求多个帐户的存储尝试的存储槽。由于某些合约具有巨大的状态，因此该方法还可以从单个帐户请求存储槽位，从特定的存储密钥哈希开始。此消息的预期用途是从远程节点获取大量后续存储槽，并在本地重建状态子序列。

- `reqID`：请求 ID 以将响应与
- `rootHash`：要服务的帐户 trie 的根哈希
- `accountHashes`：存储的帐户哈希尝试提供服务
- `startingHash`：第一个要检索的存储插槽哈希
- `limitHash`：存储插槽哈希，之后停止服务
- `responseBytes`：停止返回数据的软限制

注意：

- 节点**必须**始终响应查询。
- 如果节点**没有**所请求状态根**或任何请求的**帐户哈希的状态，**则必须**返回空回复。调用方负责查询不超过128个块的状态;并且调用方应仅查询现有帐户。
- 允许响应节点返回的数据**少于**请求的数据（服务于 QoS 限制），但该节点**必须**返回至少一个槽，除非不存在任何槽。
- 如果请求多个帐户的存储，则服务节点应使用整个存储范围进行回复（因此不需要Merkle证明），直到第一个超过数据包限制的合约。如果最后包含的存储范围不完全适合，**则必须**将Merkle证明附加到该且**仅**附加该。
- 如果请求单个帐户的存储，则服务节点应仅返回从请求的起始哈希开始的槽位，直到最后一个或数据包填满为止。如果没有返回整个存储范围**，则必须附**上Merkle证明。
- 如果附加了证明，则响应节点**必须**默克尔证明起始哈希（即使它不存在）和最后返回的插槽（如果启动哈希后存在任何插槽）。

理由：

- 响应以字节大小为上限，而不是以插槽数为上限，因为它使网络流量更具确定性。
- 该请求支持同时查询多个协定，因为大多数存储尝试的字节数约为 100 秒。单独查询这些将产生大量的网络往返行程。

警告：

- 从起始哈希请求存储槽位时，恶意节点可能会跳过并返回前缀间隙的回复。这样的回复会导致同步提前完成，并缺少大量数据。起始哈希值不存在的证明可防止此攻击，完全覆盖从头到尾的范围。
- 尽管服务节点应遵守调用方请求的响应限制，但在添加最后一个合约时，稍微强制限制（仅将其视为软限制）是有价值的，以避免必须拆分它并证明它。
- 如果在最后一个返回的插槽之后没有更多的插槽，则不需要特殊的信令，因为附加的最后一个帐户的Merkle证明将具有经过验证的路径零的所有trie节点。

todo:

### 存储范围 （0x03）

```
[reqID: P, slots: [[[slotHash: B_32, slotData: B], ...], ...], proof: [node_1: B, node_2, ...]]
```

为请求的帐户返回多个连续的存储槽（即槽列表列表），如果最后一个范围（边界证明）仅部分覆盖存储 trie，则返回可选的 Merkle 证明。左侧证明必须用于请求的源插槽（即使它不存在），右侧证明必须用于最后返回的插槽。

- `reqID`：请求的 ID 这是响应

- ```
  slots
  ```

  ：trie中连续插槽列表的列表（每个帐户一个列表）

  - `slotHash`：存储插槽密钥的哈希（trie 路径）
  - `slotData`：插槽的数据内容

- `proof`：证明插槽范围的 trie 节点列表

笔记：

- 如果插槽范围是整个存储状态，则不会沿响应发送任何证明。

### GetByteCodes （0x04）

```
[reqID: P, hashes: [hash1: B_32, hash2: B_32, ...], bytes: P]
```

按哈希请求多个合约字节码。这类似于 ，但仅限于字节码，以打破导致数据库优化问题的普遍性。此请求的预期目的是允许检索与通过 GetAccountRange 检索的帐户关联的代码，但在修复过程中也需要它。`eth/63``GetNodeData`

- `reqID`：请求 ID 以将响应与
- `hashes`：用于检索其代码的代码哈希
- `bytes`：停止返回数据的软限制

*此功能从`eth/65`复制到`snap 中`，以允许`eth`长期仅成为链维护协议，并将同步原语仅移动到卫星协议中。*

笔记：

- 节点**必须**始终响应查询。
- 返回的代码**必须**按请求顺序排列。
- 允许响应节点返回的数据**少于**请求的数据（服务于 QoS 限制），但该节点**必须**返回至少一个字节码，除非请求的字节码不可用，在这种情况下**，它必须使用**空响应进行应答。
- 如果字节码不可用，节点**必须**跳过该槽并进入下一个槽。节点**不得**返回或其他占位符。`nil`

理由：

- 响应以字节大小而不是插槽数量为上限，因为它使网络流量更具确定性，因为合约大小可以随机变化，最高可达24KB，与当前的共识规则相同。
- 通过保留原始请求顺序并跳过不可用的字节码，请求节点可以区分不可用的数据（哈希中的间隙）和 QoS 限制（缺少后缀）。

警告：

- 实现可以自由地在单个请求中请求尽可能多的字节码，但他们应该记住，由于网络延迟，请求太少会导致浪费时间;但是，如果响应不合适，请求太多会导致带宽浪费。主网上的平均（唯一）合约大小约为5-6KB，因此对于单个数据包中要请求的代码数量是一个很好的启发式方法（例如，对于512KB所需的响应大小，每个请求80-100字节码是一个不错的选择）。`bytes / 6KB`

### 字节码 （0x05）

```
[reqID: P, codes: [code1: B, code2: B, ...]]
```

返回一些请求的合约代码。顺序与请求中的顺序相同，但如果并非所有代码都可用，或者达到 QoS 限制的次数可能较少，则可能存在间隙。

### GetTrieNodes （0x06）

```
[reqID: P, rootHash: B_32, paths: [[accPath: B, slotPath1: B, slotPath2: B, ...]...], bytes: P]
```

请求多个状态（帐户或存储）Merkle trie 节点**（按路径**）。这在功能上类似于 ，但仅限于尝试和按路径查询，以打破导致数据库优化问题的普遍性。`eth/63``GetNodeData`

- `reqID`：请求 ID 以将响应与
- `rootHash`：要服务的帐户 trie 的根哈希
- `paths`：要检索其节点的 Trie 路径，按帐户分组
- `bytes`：停止返回数据的软限制

这是一个要为每个帐户检索的 trie 节点路径数组（即路径列表列表）。数组中的每个列表都特例为帐户 trie 中的第一个元素，其余元素作为存储 trie 中的路径。若要寻址帐户节点，内部列表的长度应为 1，仅包含帐户路径。部分路径（<32字节）应根据以太坊有线协议进行紧凑编码，完整路径应采用纯二进制编码。`paths`

*此功能从`eth/65`突变为`snap，`以允许`eth`长期仅成为链维护协议，并将同步原语仅移动到卫星协议中。*

笔记：

- 节点**必须**始终响应查询。
- 返回的节点**必须**按请求顺序排列。
- 如果节点**没有**所请求状态根**或任何请求的**帐户路径的状态，**则必须**返回空回复。调用方负责查询不超过128个块的状态;并且调用方应仅查询现有的 trie 节点。
- 允许响应节点返回的数据**少于**请求的数据（服务于 QoS 限制），但该节点**必须**至少返回一个 trie 节点。

理由：

- 响应以字节大小为上限，而不是以插槽数为上限，因为它使网络流量更具确定性。尽管与以前的请求类型（帐户，插槽，代码）相反，trie节点相对确定（100-500B），但如果所有数据包都遵循相同的流量整形规则，则协议仍然更干净。
- 表示 trie 节点的一种朴素方法是串联路径段的简单列表，但这在网络上会非常浪费，因为它会复制每个存储 trie 节点的帐户哈希。`account || storage`

### 三节点 （0x07）

```
[reqID: P, nodes: [node1: B, node2: B, ...]]
```

返回多个请求的状态 trie 节点。顺序与请求中的顺序相同，但达到 QoS 限制的顺序可能较少。

## 更改日志

### 快照/1（2020 年 11 月）

版本 1 是快照协议的引入。("")`