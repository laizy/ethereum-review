

# 以太坊快照协议分析（SNAP）

该协议运行在RLPx之上，便于在peer之间交换以太坊状态快照。该协议是是可选的扩展。当前版本是 snap/1。

## 概述

该协议专为半实时数据获取而设计。它的目标是为peer提供最近状态的动态快照。该协议不参与链维护（块和交易传播），应该**与`eth`协议并行运行**。

协议本身在设计上很简单（但是实现起来非常复杂）。这个协议的关键是支持从以太坊状态 trie 中查询连续的帐户段数据，或从一个特定存储 trie 中检索连续的存储槽段。这两个查询都附带了merkle证明，以便可以立即验证。此外，还可以像`eth`协议一样批量查询bytecode。

该协议的同步机制是允许peer获取和校验所有的账户和存储数据，而不需要下载merkle树的中间节点，从而减小了网络负载。最终的状态 trie 将在本地重新组装。节点必须注意的另一个复杂性是，状态会随着链进行更改，因此同步器需要支持重新组装部分一致的状态片段，这是通过类似eth的获取trie node来解决的，这样可以修复trie的不一致性。

## 与`eth`协议的关系

该协议不是完全独立的，是*依赖eth的附属协议*，要允许snap，必须要同时允许eth。这是一个深思熟虑的设计决策：

- `snap`旨在为新加入的全节点提供bootstrap功能。通过强制所有snap节点也运行eth，可以避免非完整节点无限期地一直使用snap。
- `eth`已经包含完善的链和分叉协商机制，以及同步期间的远程peer过时检测。通过并行运行这两种协议，可以受益于所有这些机制。

该协议不是下一个版本的eth，因为它依赖于*快照*加速结构的可用性，该结构可以线性迭代帐户和存储槽位。它的用途也是一种特定的同步方法，可能不适合所有客户端。保持为单独的协议允许每个客户端决定是否采用它。

## 同步算法

快照同步的关键是可以获取连续范围的帐户和存储槽，因为他们是排序过的，因此构造的Merkle证明节点非常少。此简单算法的一些重要属性：

- 与fast sync相反，我们只需要从状态trie传输有用的叶子数据，并且可以在本地重建内部节点。
- 与warp sync相反 ，我们可以下载小块的帐户和存储插槽，并立即验证其Merkle证明，从而使垃圾攻击变得不可能。
- 与warp sync相反，可以检索随机帐户范围，因此同步的并发性完全依赖于客户端实现，并且不受协议的强制。

快照同步的注意事项是快照数据会不断变化，通过自我修复，我们可以从不同的trie导入snapshot chunks。自我修复的一些重要特性：

- 同步可以随时中止，后面可以恢复。尽管中止后，可能会导致自我修复运行更长时间；
- 网络比较慢也可以保证完成（只要节点下载的速度比生成数据的快就行），数据就不会从网络中消失（与warp sync相反）。

## 数据格式

协议中的帐户类似于以太坊RLP共识编码（相同的字段，相同的顺序），但采用**细长**的格式：

- codeHash使用empty list代替`Keccak256("")`
- Root使用empty list代替`Hash(<empty trie>)`

这样减少网络上传输大量普通账户的开销。

## 协议消息
以下消息都是P2P的snap消息，识别snap消息通过对应的节点支持的protoRW标识，具体见node。其各种消息处理代码均在 `eth/protocols/snap/handler.go`

其中有以下消息类型:

```go

const (
	GetAccountRangeMsg  = 0x00
	AccountRangeMsg     = 0x01
	GetStorageRangesMsg = 0x02
	StorageRangesMsg    = 0x03
	GetByteCodesMsg     = 0x04
	ByteCodesMsg        = 0x05
	GetTrieNodesMsg     = 0x06
	TrieNodesMsg        = 0x07
)
```



### GetAccountRange （0x00）


```golang
// eth/protocols/snap/protocol.go 
// GetAccountRangePacket
type GetAccountRangePacket struct {
	ID     uint64      // 请求 ID 以便和响应关联
	Root   common.Hash // 要遍历的账户trie根哈希
	Origin common.Hash // 第一个要遍历的账户哈希
	Limit  common.Hash // 最后一个要遍历的账户哈希
	Bytes  uint64      // 返回数据的大小限制，其最大为2 * 1024 * 1024字节，超过则默认最大
}
```

从给定root为rootHash的帐户 trie中一定数量的账户数据，请求未知数量的帐户，从指定的帐户哈希开始，并以允许的最大响应大小（以字节为单位）为上限：

注意：

- 节点**必须**始终响应查询。
- 如果节点**没有**所请求状态根的状态，**则必须**返回空回复。调用方负责查询不超过 128 个块的状态。
- 允许响应节点返回的数据**少于**请求的数据（自己的 QoS 限制），但该节点**必须**至少返回一个帐户。如果在startingHash和limitHash之间不存在任何账户，则必须提供**之后**的第一个（如果有）帐户。
- 响应节点**必须**给出startingHash（即使这个账户不存在）和最后返回账户的默克尔证明。

理由：

- 起始帐户是故意通过哈希而不是地址来标识的。由于以太坊Merkle trie中的帐户按哈希排序，因此地址无关紧要。此外，没有共识要求全节点知道地址的pre-images。
- 响应以字节大小为上限，而不是以帐户数为上限，因为它使网络流量更具确定性。由于账户状态密度是不可知的，因此也无法仅用结束哈希来分隔查询。

警告：

- 从起始哈希请求帐户时，恶意节点可能会跳过并返回空隙回复。这样的回复会导致同步提前完成，并缺少大量数据。起始哈希值不存在的证明可防止此攻击，完全覆盖从头到尾的范围。
- 如果在最后一个返回的帐户之后没有更多的帐户，则不需要特殊信号，因为附加的最后一个帐户的Merkle证明的节点将都会是右边的节点。

发送消息: 

```go
// RequestAccountRange fetch在特定trie根下的一系列的账户。
func (p *Peer) RequestAccountRange(id uint64, root common.Hash, origin, limit common.Hash, bytes uint64) error;

```



### AccountRange（0x01）

```go
// AccountData 代表对查询请求的单个账户
type AccountData struct {
	Hash common.Hash  // 账户哈希
	Body rlp.RawValue // slim账户内容的rlp编码
}

// AccountRangePacket 对GetAccountRange请求的响应.
type AccountRangePacket struct {
	ID       uint64         // 此响应对应的请求ID。
	Accounts []*AccountData // 账户数据列表
	Proof    [][]byte       // 证明账户账户范围的一系列trie节点
}
```

返回多个连续帐户和整个范围的 Merkle 边界证明。左侧证明必须用于请求的来源哈希（即使关联账户不存在），右侧证明必须是最后一个返回的账户。

注意：

- 如果返回的响应包含了完整的状态，这可以不发送proof。对于账户来说可能不常见，但是对于存储来说很常见，因此这样子可以统一两者的行为。 




### GetStorageRanges （0x02）

```go
// GetStorageRangesPacket 对storage slot的查询
type GetStorageRangesPacket struct {
	ID       uint64        // 请求的Id
	Root     common.Hash   // 请求查询的storage slots所在的账户trie的根哈希。
	Accounts []common.Hash // 请求查询的账户哈希
	Origin   []byte        // 第一个遍历的存储槽哈希 (large contract mode)
	Limit    []byte        // 最后一个遍历的存储槽哈希 (large contract mode)
	Bytes    uint64        // 数据大小的字节限制，其最大值为 2MB
}
```

请求多个帐户的多个存储槽。由于某些合约拥有很多存储槽，因此该方法还可以从单个帐户请求多个存储槽位。此消息的预期用途是从对端节点获取大量连续存储槽，并在本地重建对应账户的存储trie。

注意：

- 节点**必须**始终响应查询。
- 如果节点**没有**所请求状态根**或任何请求的**帐户哈希的状态，**则必须**返回空回复。调用方负责查询不超过128个块的状态;并且调用方应仅查询现有帐户。
- 允许响应节点返回的数据**少于**请求的数据（服务于 QoS 限制），但该节点**必须**返回至少一个槽，除非不存在任何槽。
- 如果请求多个帐户的存储，则服务节点应使用整个存储范围进行回复（因此不需要Merkle证明），直到第一个超过数据包限制的合约。如果最后包含的存储范围不完全适合，**则只需要**将Merkle证明附加到**此**存储范围。
- 如果请求单个帐户的存储，则服务节点应仅返回从请求的起始哈希开始的槽位，直到最后一个或数据包填满为止。如果没有返回整个存储范围**，则必须附**上Merkle证明。
- 如果附加了证明，则响应节点**必须**默克尔证明起始哈希（即使它不存在）和最后返回的插槽（如果起始哈希后存在插槽）。

理由：

- 响应以字节大小为上限，而不是以插槽数为上限，因为它使网络流量更具确定性。
- 该请求支持同时查询多个合约，因为大多数存储trie的字节数约为 100_000。单独查询这些将产生大量的网络往返开销。

警告：

- 从起始哈希请求存储槽位时，恶意节点可能会跳过并返回前缀间隙的回复。这样的回复会导致同步提前完成，并缺少大量数据。对起始hash的所有存储槽都进行merkle证明，即使它不存在，则可解决这个问题。
- 尽管服务节点应遵守调用方请求的响应大小限制，但如果正好到添加最后一个合约时，允许稍微放大limit，实现使用的是1.1倍，以避免拆分状态和提供证明。
- 如果在最后一个返回的插槽之后没有更多的插槽，则不需要特殊的标记，因为附加的最后一个帐户的Merkle证明能够说明它确实是最后一个。


### StorageRanges （0x03）

```
[reqID: P, slots: [[[slotHash: B_32, slotData: B], ...], ...], proof: [node_1: B, node_2, ...]]
```

为请求的帐户返回多个连续的存储槽，如果最后一个只覆盖了部分存储trie的数据，则需要提供范围证明。左侧证明必须使用请求的origin slot（即使它不存在），右侧证明必须使用最后返回的插槽。

- `reqID`：响应的请求ID

- slots：trie中连续插槽列表的列表（每个帐户一个列表）
  - `slotHash`：slot key的hash（trie 路径）
  - `slotData`：slot的数据内容

- `proof`：证明slot范围的trie节点列表

笔记：

- 如果插槽范围是整个存储状态，则不需要发送证明。

### GetByteCodes （0x04）

```
[reqID: P, hashes: [hash1: B_32, hash2: B_32, ...], bytes: P]
```

按合约字节码哈希请求多个合约字节码。其类似于eth/66协议的GetNodeData方法，但是仅限于字节码。此请求的目的是检索GetAccountRange 检索到的合约相关联的代码。此外，在系统修复过程中也会用到此方法。

- `reqID`：请求ID
- `hashes`：检索的合约代码哈希
- `bytes`：返回数据大小的软限制


笔记：

- 节点**必须**始终响应查询。
- 返回的代码**必须**按请求顺序排列。
- 允许响应节点返回的数据**少于**请求的数据（服务于 QoS 限制），但该节点**必须**返回至少一个字节码，除非请求的字节码不可用，在这种情况下**，它必须使用**空响应进行应答。
- 如果字节码不可用，节点**必须**跳过该槽并进入下一个槽，不能使用nil作为占位符。

理由：

- 响应以字节大小而不是插槽数量为上限，因为它使网络流量更具确定性，因为合约大小可以随机变化，最高可达24KB，与当前的共识规则相关。
- 通过保留原始请求顺序并跳过不可用的字节码，请求节点可以区分不可用的数据（哈希中的间隙）和 QoS 限制没有返回完所需合约字节。

警告：

- 单个请求中可以请求尽可能多的合约字节码，由于网络延迟，请求太少会导致浪费时间；但是请求过多会导致带宽浪费，（因为有qos的限制，请求时发送多余的合约字节哈希会造成宽带浪费）。主网上的平均合约大小约为5-6KB，因此对于单个数据包中要请求的合约代码数量可以进行估计，（例如，对于512KB所需的响应大小，每个请求80-100个合约字节码是一个不错的选择）。

### ByteCodes （0x05）

```
[reqID: P, codes: [code1: B, code2: B, ...]]
```

返回请求的一系列合约代码。顺序与请求时的顺序相同，但如果没有对应的合约代码，或者达到 QoS 限制，则返回次数可能较少，则返回的合约代码可能存在间隙如请求了hash(1),hash(2),hash(3)，得到了1,3，可通过检查对应的哈希与请求哈希来识别。

### GetTrieNodes （0x06）

```
[reqID: P, rootHash: B_32, paths: [[accPath: B, slotPath1: B, slotPath2: B, ...]...], bytes: P]
```

按路径请求多个状态（帐户或存储）的Merkle trie节点。这在功能上类似于eth/66协议的GetNodeData ，但仅限于对特定的账户trie和特定路径进行查询，由于snap协议的运行前提是本地存储了snapshot数据，所以此限制必须从查询snapshot中的数据信息。而eth/66则最终会直接从数据库中拿取对应节点。

- `reqID`：请求ID
- `rootHash`：要请求的帐户 trie 的根哈希
- `paths`：要检索对应节点的Trie路径，按帐户分组
- `bytes`：停止返回数据的软限制

paths是每个帐户检索的trie节点路径数组。此数组中的元素为路径信息，第一个为帐户路径，其余为存储trie中的路径。若只要帐户节点，路径列表的长度应为1。部分路径（<32字节）应根据以太坊wire协议进行compact编码，完整路径应采用纯二进制编码。

笔记：

- 节点**必须**始终响应查询。
- 返回的节点**必须**按请求顺序排列。
- 如果节点**没有**所请求状态根的状态数据**或任何请求的**帐户路径的状态，**则必须**返回空回复。调用方负责查询不超过最新区块前128个块的状态;并且调用方应仅查询存在的 trie 节点。
- 允许响应节点返回的数据**少于**请求的数据（服务于 QoS 限制），但该节点**必须**至少返回一个 trie 节点。

理由：

- 响应以字节大小为上限，而不是以插槽数为上限，尽管trie节点的大小相对确定（100-500B），但保持和其他数据包一样的方式使得协议更干净。

### TrieNodes （0x07）

```
[reqID: P, nodes: [node1: B, node2: B, ...]]
```

返回多个请求的状态 trie 节点。顺序与请求中的顺序相同，但达到 QoS 限制时，返回的数量可能较少。

